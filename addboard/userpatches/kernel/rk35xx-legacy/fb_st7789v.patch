diff --git a/drivers/staging/fbtft/fb_st7789v.c b/drivers/staging/fbtft/fb_st7789v.c
index fe6852610910..102v254fd6dc 100644
--- a/drivers/staging/fbtft/fb_st7789v.c
+++ b/drivers/staging/fbtft/fb_st7789v.c
@@ -7,9 +7,13 @@
 
 #include <linux/bitops.h>
 #include <linux/delay.h>
+#include <linux/gpio/consumer.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/completion.h>
 #include <linux/module.h>
+
 #include <video/mipi_display.h>
 
 #include "fbtft.h"
@@ -66,6 +70,18 @@
 #define MADCTL_MX BIT(6) /* bitmask for column address order */
 #define MADCTL_MY BIT(7) /* bitmask for page address order */
 
+/* 60Hz for 16.6ms, configured as 2*16.6ms */
+#define PANEL_TE_TIMEOUT_MS  33
+
+static struct completion panel_te; /* completion for panel TE line */
+static int irq_te; /* Linux IRQ for LCD TE line */
+
+static irqreturn_t panel_te_handler(int irq, void *data)
+{
+	complete(&panel_te);
+	return IRQ_HANDLED;
+}
+
 /**
  * init_display() - initialize the display controller
  *
@@ -83,68 +99,79 @@
 static int init_display(struct fbtft_par *par)
 {
 	par->fbtftops.reset(par);
-
-	/* turn off sleep mode */
-	write_reg(par, MIPI_DCS_EXIT_SLEEP_MODE);
+	mdelay(100);
+	write_reg(par,0x11); //软复位
 	mdelay(120);
+	//下面添加初始化函数write_reg 参数分别为：结构体指针，写命令，写数据....(后都为数据)
+	//ST7789v Frame Rate
+	write_reg(par,0xB1,0x05,0x3C,0x3C); //Normal mode
+	write_reg(par,0xB2,0x05,0x3C,0x3C); //Idle mode
+	write_reg(par,0xB3,0x05,0x3C,0x3C,0x05,0x3C,0x3C); //Partial mode
+	write_reg(par,0xB4,0x03); //Column inversion
+	//ST7789v Power Sequence
+	write_reg(par,0xC0,0xAB,0x0B,0x04); //AVDD GVDD
+	write_reg(par,0xC1,0xC5); //VGH VGL C0
+	write_reg(par,0xC2,0x0D,0x00); //Normal Mode
+	write_reg(par,0xC3,0x8D,0x6A); //Idle
+	write_reg(par,0xC4,0x8D,0xEE); //MX, MY, RGB mode
+	write_reg(par,0xC5,0x0F); //VCOM
+	//ST7789v Gamma Sequence
+	write_reg(par,0xE0,0x07,0x0E,0x08,0x07,0x10,0x07,0x02,0x07,0x09,0x0F,0x25,0x36,0x00,0x08,0x04,0x10); //positive gamma
+	write_reg(par,0xE1,0x0A,0x0D,0x08,0x07,0x0F,0x07,0x02,0x07,0x09,0x0F,0x25,0x35,0x00,0x09,0x04,0x10); //negative gamma
+	write_reg(par,0xFC,0x80);
+	write_reg(par,0x3A,0x05); //65k mode
+	write_reg(par,0x36,0x08);
+	//write_reg(par, 0x21); //Display inversion
+	write_reg(par,0x29); //Display on
+	write_reg(par,0x2A,0x00,0x1A,0x00,0x69); //Set Column Address
+	write_reg(par,0x2B,0x00,0x01,0x00,0xA0); //Set Page Address
+	write_reg(par,0x2C);
+	
+	return 0;
+}
 
-	/* set pixel format to RGB-565 */
-	write_reg(par, MIPI_DCS_SET_PIXEL_FORMAT, MIPI_DCS_PIXEL_FMT_16BIT);
-	if (HSD20_IPS)
-		write_reg(par, PORCTRL, 0x05, 0x05, 0x00, 0x33, 0x33);
-
-	else
-		write_reg(par, PORCTRL, 0x08, 0x08, 0x00, 0x22, 0x22);
-
-	/*
-	 * VGH = 13.26V
-	 * VGL = -10.43V
-	 */
-	if (HSD20_IPS)
-		write_reg(par, GCTRL, 0x75);
-	else
-		write_reg(par, GCTRL, 0x35);
-
-	/*
-	 * VDV and VRH register values come from command write
-	 * (instead of NVM)
-	 */
-	write_reg(par, VDVVRHEN, 0x01, 0xFF);
-
-	/*
-	 * VAP =  4.1V + (VCOM + VCOM offset + 0.5 * VDV)
-	 * VAN = -4.1V + (VCOM + VCOM offset + 0.5 * VDV)
-	 */
-	if (HSD20_IPS)
-		write_reg(par, VRHS, 0x13);
-	else
-		write_reg(par, VRHS, 0x0B);
-
-	/* VDV = 0V */
-	write_reg(par, VDVS, 0x20);
-
-	/* VCOM = 0.9V */
-	if (HSD20_IPS)
-		write_reg(par, VCOMS, 0x22);
-	else
-		write_reg(par, VCOMS, 0x20);
-
-	/* VCOM offset = 0V */
-	write_reg(par, VCMOFSET, 0x20);
+/*
+ * write_vmem() - write data to display.
+ * @par: FBTFT parameter object.
+ * @offset: offset from screen_buffer.
+ * @len: the length of data to be writte.
+ *
+ * Return: 0 on success, or a negative error code otherwise.
+ */
+static int write_vmem(struct fbtft_par *par, size_t offset, size_t len)
+{
+	struct device *dev = par->info->device;
+	int ret;
 
-	/*
-	 * AVDD = 6.8V
-	 * AVCL = -4.8V
-	 * VDS = 2.3V
-	 */
-	write_reg(par, PWCTRL1, 0xA4, 0xA1);
+	if (irq_te) {
+		enable_irq(irq_te);
+		reinit_completion(&panel_te);
+		ret = wait_for_completion_timeout(&panel_te,
+						  msecs_to_jiffies(PANEL_TE_TIMEOUT_MS));
+		if (ret == 0)
+			dev_err(dev, "wait panel TE timeout\n");
 
-	write_reg(par, MIPI_DCS_SET_DISPLAY_ON);
+		disable_irq(irq_te);
+	}
 
-	if (HSD20_IPS)
-		write_reg(par, MIPI_DCS_ENTER_INVERT_MODE);
+	switch (par->pdata->display.buswidth) {
+	case 8:
+		ret = fbtft_write_vmem16_bus8(par, offset, len);
+		break;
+	case 9:
+		ret = fbtft_write_vmem16_bus9(par, offset, len);
+		break;
+	case 16:
+		ret = fbtft_write_vmem16_bus16(par, offset, len);
+		break;
+	default:
+		dev_err(dev, "Unsupported buswidth %d\n",
+			par->pdata->display.buswidth);
+		ret = 0;
+		break;
+	}
 
-	return 0;
+	return ret;
 }
 
 /**
@@ -252,18 +279,59 @@
 	return 0;
 }
 
+static void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)
+{
+	switch(par->info->var.rotate)
+	{
+		case   0: xs += 24; xe += 24;
+				 break;
+		case  90: ys += 24; ye += 24;
+				 break;
+		case 180: xs += 24; xe += 24;
+				 break;
+		case 270: ys += 24; ye += 24;
+				 break;
+		default :
+				 break;
+	}
+
+	write_reg(par, MIPI_DCS_SET_COLUMN_ADDRESS,
+		  (xs >> 8) & 0xFF, xs & 0xFF, (xe >> 8) & 0xFF, xe & 0xFF);
+
+	write_reg(par, MIPI_DCS_SET_PAGE_ADDRESS,
+		  (ys >> 8) & 0xFF, ys & 0xFF, (ye >> 8) & 0xFF, ye & 0xFF);
+
+	write_reg(par, MIPI_DCS_WRITE_MEMORY_START);
+}
+
+static void reset(struct fbtft_par *par)
+{
+	if (!par->gpio.reset)
+		return;
+	fbtft_par_dbg(DEBUG_RESET, par, "%s()\n", __func__);
+	gpiod_set_value_cansleep(par->gpio.reset, 1);
+	msleep(10);
+	gpiod_set_value_cansleep(par->gpio.reset, 0);
+	msleep(200);
+	gpiod_set_value_cansleep(par->gpio.reset, 1);
+	msleep(10);
+}
+
 static struct fbtft_display display = {
 	.regwidth = 8,
-	.width = 240,
-	.height = 320,
+	.width = 80,
+	.height = 160,
 	.gamma_num = 2,
 	.gamma_len = 14,
 	.gamma = HSD20_IPS_GAMMA,
 	.fbtftops = {
 		.init_display = init_display,
+		.set_addr_win = set_addr_win,
+		.write_vmem = write_vmem,
 		.set_var = set_var,
 		.set_gamma = set_gamma,
 		.blank = blank,
+		.reset = reset,
 	},
 };
 
